package main

import (
	"bytes"
	"flag"
	"fmt"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"os"
	"strings"
	"text/template"
)

const header = `// Code generated by %s; DO NOT EDIT.

package %s

`

const testHeaderImport = `import (
	. "github.com/franela/goblin"
	"testing"
)
`

const iteratorHeaderImport = `import "sync"
`

const iteratorAll = `
func ({{ReceiverName}} {{ReceiverType}}) ForEach{{MethodNameExtension}}I(f func({{FuncParameterName}} {{FuncParameterType}}, index int)) {
	index := 0
	iter := func({{IterParamName}} []{{FuncParameterType}}) {
		for _, {{ForVarName}} := range {{IterParamName}} {
			f({{ForVarName}}, index)
			index++
		}
	}
{{Iterators}}
}

func ({{ReceiverName}} {{ReceiverType}}) GoForEach{{MethodNameExtension}}I(f func({{FuncParameterName}} {{FuncParameterType}}, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func({{IterParamName}} []{{FuncParameterType}}) {
		wg.Add(len({{IterParamName}}))
		for _, {{ForVarName}} := range {{IterParamName}} {
			index++
			index := index
			{{ForVarName}} := {{ForVarName}}
			go func() {
				f({{ForVarName}}, index)
				wg.Done()
			}()
		}
	}
{{Iterators}}
	return wg.Wait
}

func ({{ReceiverName}} {{ReceiverType}}) ForEach{{MethodNameExtension}}(f func({{FuncParameterName}} {{FuncParameterType}})) {
	{{ReceiverName}}.ForEach{{MethodNameExtension}}I(func({{FuncParameterName}} {{FuncParameterType}}, index int) {
		f({{FuncParameterName}})
	})
}

func ({{ReceiverName}} {{ReceiverType}}) GoForEach{{MethodNameExtension}}(f func({{FuncParameterName}} {{FuncParameterType}})) func() {
	return {{ReceiverName}}.GoForEach{{MethodNameExtension}}I(func({{FuncParameterName}} {{FuncParameterType}}, index int) {
		f({{FuncParameterName}})
	})
}
`

const testAll = `
func Test{{ReceiverType}}{{MethodNameExtension}}_Iterators(t *testing.T) {
    g := Goblin(t)
    g.Describe("Test{{ReceiverType}}_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			{{ReceiverName}} := {{ReceiverType}}{}
{{IteratorsTest}}
			{{ReceiverName}}.ForEach{{MethodNameExtension}}(func({{FuncParameterName}} {{FuncParameterType}}) {
				c++
			})
			g.Assert(c).Equal({{TestCount }} * {{ IteratorCount}})
		})
		g.It("Has a working GoForEach method", func() {
			{{ReceiverName}} := {{ReceiverType}}{}
{{IteratorsTest}}
			c := make(chan bool, {{TestCount -}} * {{- IteratorCount}})
			{{ReceiverName}}.GoForEach{{MethodNameExtension}}(func({{FuncParameterName}} {{FuncParameterType}}) {
				c <- true
			})()
			for i := 0; i < {{TestCount -}} * {{- IteratorCount}}; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}    
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			{{ReceiverName}} := {{ReceiverType}}{}
{{IteratorsTest}}

			{{ReceiverName}}.ForEach{{MethodNameExtension}}I(func({{FuncParameterName}} {{FuncParameterType}}, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal({{TestCount -}} * {{- IteratorCount}})
		})
		g.It("Has a working GoForEachI method", func() {
			{{ReceiverName}} := {{ReceiverType}}{}
{{IteratorsTest}}

			c := make(chan int, {{TestCount -}} * {{- IteratorCount}})
			{{ReceiverName}}.GoForEach{{MethodNameExtension}}I(func({{FuncParameterName}} {{FuncParameterType}}, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < {{TestCount -}} * {{- IteratorCount}}; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal({{TestCount -}} * {{- IteratorCount}}*({{TestCount -}} * {{- IteratorCount}}+1)/2 - {{TestCount -}} * {{- IteratorCount}})
		})
	})
}

func Benchmark{{ReceiverType}}_ForEach{{MethodNameExtension}}(b *testing.B) {
	{{ReceiverName}} := {{ReceiverType}}{}
{{IteratorsBench}}
	b.ReportAllocs()
	b.ResetTimer()
	{{ReceiverName}}.ForEach{{MethodNameExtension}}(func({{FuncParameterName}} {{FuncParameterType}}) {
		
	})
}

func Benchmark{{ReceiverType}}_GoForEach{{MethodNameExtension}}(b *testing.B) {
	{{ReceiverName}} := {{ReceiverType}}{}
{{IteratorsBench}}
	b.ReportAllocs()
	b.ResetTimer()
	{{ReceiverName}}.GoForEach{{MethodNameExtension}}(func({{FuncParameterName}} {{FuncParameterType}}) {
		
	})()
}
`

const iterator = `	iter({{CastBegin}}{{ReceiverName}}{{FieldToIterate}}{{CastEnd}})
`

const iteratorTest = `			{{ReceiverName}}{{FieldToIterate}} = make([]{{FuncParameterType}}, {{TestCount}})
`

const iteratorBench = `	{{ReceiverName}}{{FieldToIterate}} = make([]{{FuncParameterType}}, b.N)
`

type IteratorGenerationInstructions struct {
	TestCount int `yaml:"TestCount"`
	List      []struct {
		ReceiverName        string   `yaml:"ReceiverName"`
		ReceiverType        string   `yaml:"ReceiverType"`
		MethodNameExtension string   `yaml:"MethodNameExtension"`
		FuncParameterName   string   `yaml:"FuncParameterName"`
		FuncParameterType   string   `yaml:"FuncParameterType"`
		IterParamName       string   `yaml:"IterParamName"`
		ForVarName          string   `yaml:"ForVarName"`
		CastTo              string   `yaml:"CastTo"`
		IterOnFields        []string `yaml:"IterOnFields"`
	} `yaml:"List"`
}

func (i IteratorGenerationInstructions) getIterators(in int) string {
	var b []byte
	buf := bytes.NewBuffer(b)
	for _, f := range i.List[in].IterOnFields {
		t, err := template.New("Iterators").Funcs(template.FuncMap{
			"ReceiverName":   func() string { return i.List[in].ReceiverName },
			"FieldToIterate": func() string { return f },
			"CastBegin": func() string {
				if i.List[in].CastTo == "" {
					return ""
				}
				return i.List[in].CastTo + "("
			},
			"CastEnd": func() string {
				if i.List[in].CastTo == "" {
					return ""
				}
				return ")"
			},
		}).Parse(iterator)
		if err != nil {
			panic(err)
		}
		err = t.Execute(buf, iterator)
		if err != nil {
			panic(err)
		}
	}
	return buf.String()
}

func (i IteratorGenerationInstructions) getTestIteratorsTest(in int) string {
	var b []byte
	buf := bytes.NewBuffer(b)
	for _, f := range i.List[in].IterOnFields {
		t, err := template.New("IteratorsTest").Funcs(template.FuncMap{
			"ReceiverName":      func() string { return i.List[in].ReceiverName },
			"FieldToIterate":    func() string { return f },
			"FuncParameterType": func() string { return i.List[in].FuncParameterType },
			"TestCount":         func() int { return i.TestCount },
		}).Parse(iteratorTest)
		if err != nil {
			panic(err)
		}
		err = t.Execute(buf, iteratorTest)
		if err != nil {
			panic(err)
		}
	}
	return buf.String()
}

func (i IteratorGenerationInstructions) getTestIteratorsBench(in int) string {
	var b []byte
	buf := bytes.NewBuffer(b)
	for _, f := range i.List[in].IterOnFields {
		t, err := template.New("IteratorsBench").Funcs(template.FuncMap{
			"ReceiverName":      func() string { return i.List[in].ReceiverName },
			"FieldToIterate":    func() string { return f },
			"FuncParameterType": func() string { return i.List[in].FuncParameterType },
			"TestCount":         func() int { return i.TestCount },
		}).Parse(iteratorBench)
		if err != nil {
			panic(err)
		}
		err = t.Execute(buf, iteratorBench)
		if err != nil {
			panic(err)
		}
	}
	return buf.String()
}

func (i IteratorGenerationInstructions) getFunction(in int) string {
	var b []byte
	buf := bytes.NewBuffer(b)
	t, err := template.New("Iterators").Funcs(template.FuncMap{
		"ReceiverName":        func() string { return i.List[in].ReceiverName },
		"ReceiverType":        func() string { return i.List[in].ReceiverType },
		"MethodNameExtension": func() string { return i.List[in].MethodNameExtension },
		"FuncParameterName":   func() string { return i.List[in].FuncParameterName },
		"FuncParameterType":   func() string { return i.List[in].FuncParameterType },
		"IterParamName":       func() string { return i.List[in].IterParamName },
		"ForVarName":          func() string { return i.List[in].ForVarName },
		"Iterators":           func() string { return i.getIterators(in) },
	}).Parse(iteratorAll)
	if err != nil {
		panic(err)
	}
	err = t.Execute(buf, iteratorAll)
	if err != nil {
		panic(err)
	}
	return buf.String()
}

func (i IteratorGenerationInstructions) getTestFunction(in int) string {
	var b []byte
	buf := bytes.NewBuffer(b)
	t, err := template.New("IteratorsTest").Funcs(template.FuncMap{
		"ReceiverName":        func() string { return i.List[in].ReceiverName },
		"ReceiverType":        func() string { return i.List[in].ReceiverType },
		"MethodNameExtension": func() string { return i.List[in].MethodNameExtension },
		"FuncParameterName":   func() string { return i.List[in].FuncParameterName },
		"FuncParameterType":   func() string { return i.List[in].FuncParameterType },
		"IterParamName":       func() string { return i.List[in].IterParamName },
		"ForVarName":          func() string { return i.List[in].ForVarName },
		"IteratorCount":       func() int { return len(i.List[in].IterOnFields) },
		"TestCount":           func() int { return i.TestCount },
		"IteratorsTest":       func() string { return i.getTestIteratorsTest(in) },
		"IteratorsBench":      func() string { return i.getTestIteratorsBench(in) },
	}).Parse(testAll)
	if err != nil {
		panic(err)
	}
	err = t.Execute(buf, testAll)
	if err != nil {
		panic(err)
	}
	return buf.String()
}

func (i IteratorGenerationInstructions) getFunctions() string {
	var str string
	for j := range i.List {
		str += i.getFunction(j)
	}
	return str
}

func (i IteratorGenerationInstructions) getTestFunctions() string {
	var str string
	for j := range i.List {
		str += i.getTestFunction(j)
	}
	return str
}

func main() {
	var o string
	var i string
	var p string
	flag.StringVar(&o, "o", "", "")
	flag.StringVar(&i, "i", "", "")
	flag.StringVar(&p, "p", "", "")
	flag.Parse()

	var f *os.File
	var err error
	fInput, err := os.Open(i)
	if err != nil {
		panic(err)
	}
	inputByte, err := ioutil.ReadAll(fInput)
	if err != nil {
		panic(err)
	}
	var instructions IteratorGenerationInstructions
	if err = yaml.UnmarshalStrict(inputByte, &instructions); err != nil {
		panic(err)
	}
	if o == "" {
		f = os.Stdout
	} else {
		if f, err = os.Create(o); err != nil {
			panic(err)
		}
	}

	if _, err = fmt.Fprintf(f, header+iteratorHeaderImport, strings.Join(os.Args, " "), p); err != nil {
		panic(err)
	}
	if _, err = fmt.Fprintf(f, "%s", instructions.getFunctions()); err != nil {
		panic(err)
	}

	if o == "" {
		return
	}
	if f, err = os.Create(strings.TrimRight(o, ".go") + "_test.go"); err != nil {
		panic(err)
	}

	if _, err = fmt.Fprintf(f, header+testHeaderImport, strings.Join(os.Args, " "), p); err != nil {
		panic(err)
	}
	if _, err = fmt.Fprintf(f, "%s", instructions.getTestFunctions()); err != nil {
		panic(err)
	}
}
