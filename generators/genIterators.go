package main

import (
	"bytes"
	"flag"
	"fmt"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"os"
	"strings"
	"text/template"
)

const header = `// Code generated by %s; DO NOT EDIT.

package %s

`

const testHeaderImport = `import (
	. "github.com/franela/goblin"
	"testing"
)
`

const iteratorHeaderImport = `import "sync"
`

const iteratorForEach = `
func ({{ReceiverName}} {{ReceiverType}}) ForEach{{MethodNameExtension}}(f func({{FuncParameterName}} {{FuncParameterType}})) {
	iter := func({{IterParamName}} []{{FuncParameterType}}) {
		for _, {{ForVarName}} := range {{IterParamName}} {
			f({{ForVarName}})
		}
	}
{{Iterators}}
}
`

const iteratorForEachAsync = `
func ({{ReceiverName}} {{ReceiverType}}) ForEach{{MethodNameExtension}}Async(f func({{FuncParameterName}} {{FuncParameterType}})) {
	var wg sync.WaitGroup
	iter := func({{IterParamName}} []{{FuncParameterType}}) {
		wg.Add(len({{IterParamName}}))
		for _, {{ForVarName}} := range {{IterParamName}} {
			f({{ForVarName}})
			wg.Done()
		}
	}
{{Iterators}}
	wg.Wait()
}
`

const iteratorGoForEach = `
func ({{ReceiverName}} {{ReceiverType}}) GoForEach{{MethodNameExtension}}(f func({{FuncParameterName}} {{FuncParameterType}})) func() {
	var wg sync.WaitGroup
	iter := func({{IterParamName}} []{{FuncParameterType}}) {
		wg.Add(len({{IterParamName}}))
		for _, {{ForVarName}} := range {{IterParamName}} {
			f({{ForVarName}})
			wg.Done()
		}
	}
{{Iterators}}
	return wg.Wait
}
`

const testAll3 = `func Test{{ReceiverType}}{{MethodNameExtension}}_Iterators(t *testing.T) {
    g := Goblin(t)
    g.Describe("Test{{ReceiverType}}_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			{{ReceiverName}} := {{ReceiverType}}{}
{{Iterators}}
			{{ReceiverName}}.ForEach{{MethodNameExtension}}(func({{FuncParameterName}} {{FuncParameterType}}) {
				c++
			})
			g.Assert(c).Equal({{TestCount}} * {{IteratorCount}})
		})
		g.It("Have a working ForEachAsync method", func() {
			{{ReceiverName}} := {{ReceiverType}}{}
{{Iterators}}
			c := make(chan bool, {{TestCount}} * {{IteratorCount}})
			{{ReceiverName}}.ForEach{{MethodNameExtension}}Async(func({{FuncParameterName}} {{FuncParameterType}}) {
				c <- true
			})
			for i := 0; i < {{TestCount}} * {{IteratorCount}}; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			{{ReceiverName}} := {{ReceiverType}}{}
{{Iterators}}
			c := make(chan bool, {{TestCount}} * {{IteratorCount}})
			{{ReceiverName}}.GoForEach{{MethodNameExtension}}(func({{FuncParameterName}} {{FuncParameterType}}) {
				c <- true
			})()
			for i := 0; i < {{TestCount}} * {{IteratorCount}}; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}    
		})
	})
}
`

var allThree = iteratorForEach + iteratorForEachAsync + iteratorGoForEach

const iterator = `	iter({{CastBegin}}{{ReceiverName}}{{FieldToIterate}}{{CastEnd}})
`

const iteratorTest = `			{{ReceiverName}}{{FieldToIterate}} = make([]{{FuncParameterType}}, {{TestCount}})
`

type IteratorGenerationInstructions struct {
	List []struct {
		ReceiverName        string   `yaml:"ReceiverName"`
		ReceiverType        string   `yaml:"ReceiverType"`
		MethodNameExtension string   `yaml:"MethodNameExtension"`
		FuncParameterName   string   `yaml:"FuncParameterName"`
		FuncParameterType   string   `yaml:"FuncParameterType"`
		IterParamName       string   `yaml:"IterParamName"`
		ForVarName          string   `yaml:"ForVarName"`
		CastTo              string   `yaml:"CastTo"`
		IterOnFields        []string `yaml:"IterOnFields"`
		TestCount           int      `yaml:"TestCount"`
	} `yaml:"List"`
}

func (i IteratorGenerationInstructions) getIterators(in int) string {
	var b []byte
	buf := bytes.NewBuffer(b)
	for _, f := range i.List[in].IterOnFields {
		t, err := template.New("Iterators").Funcs(template.FuncMap{
			"ReceiverName":   func() string { return i.List[in].ReceiverName },
			"FieldToIterate": func() string { return f },
			"CastBegin": func() string {
				if i.List[in].CastTo == "" {
					return ""
				}
				return i.List[in].CastTo + "("
			},
			"CastEnd": func() string {
				if i.List[in].CastTo == "" {
					return ""
				}
				return ")"
			},
		}).Parse(iterator)
		if err != nil {
			panic(err)
		}
		err = t.Execute(buf, iterator)
		if err != nil {
			panic(err)
		}
	}
	return buf.String()
}

func (i IteratorGenerationInstructions) getTestIterators(in int) string {
	var b []byte
	buf := bytes.NewBuffer(b)
	for _, f := range i.List[in].IterOnFields {
		t, err := template.New("IteratorsTest").Funcs(template.FuncMap{
			"ReceiverName":      func() string { return i.List[in].ReceiverName },
			"FieldToIterate":    func() string { return f },
			"FuncParameterType": func() string { return i.List[in].FuncParameterType },
			"TestCount": func() int {
				if i.List[in].TestCount == 0 {
					return 10
				}
				return i.List[in].TestCount
			},
		}).Parse(iteratorTest)
		if err != nil {
			panic(err)
		}
		err = t.Execute(buf, iteratorTest)
		if err != nil {
			panic(err)
		}
	}
	return buf.String()
}

func (i IteratorGenerationInstructions) getFunction(in int) string {
	var b []byte
	buf := bytes.NewBuffer(b)
	t, err := template.New("Iterators").Funcs(template.FuncMap{
		"ReceiverName":        func() string { return i.List[in].ReceiverName },
		"ReceiverType":        func() string { return i.List[in].ReceiverType },
		"MethodNameExtension": func() string { return i.List[in].MethodNameExtension },
		"FuncParameterName":   func() string { return i.List[in].FuncParameterName },
		"FuncParameterType":   func() string { return i.List[in].FuncParameterType },
		"IterParamName":       func() string { return i.List[in].IterParamName },
		"ForVarName":          func() string { return i.List[in].ForVarName },
		"Iterators":           func() string { return i.getIterators(in) },
	}).Parse(allThree)
	if err != nil {
		panic(err)
	}
	err = t.Execute(buf, allThree)
	if err != nil {
		panic(err)
	}
	return buf.String()
}

func (i IteratorGenerationInstructions) getTestFunction(in int) string {
	var b []byte
	buf := bytes.NewBuffer(b)
	t, err := template.New("IteratorsTest").Funcs(template.FuncMap{
		"ReceiverName":        func() string { return i.List[in].ReceiverName },
		"ReceiverType":        func() string { return i.List[in].ReceiverType },
		"MethodNameExtension": func() string { return i.List[in].MethodNameExtension },
		"FuncParameterName":   func() string { return i.List[in].FuncParameterName },
		"FuncParameterType":   func() string { return i.List[in].FuncParameterType },
		"IterParamName":       func() string { return i.List[in].IterParamName },
		"ForVarName":          func() string { return i.List[in].ForVarName },
		"IteratorCount":       func() int { return len(i.List[in].IterOnFields) },
		"TestCount": func() int {
			if i.List[in].TestCount == 0 {
				return 10
			}
			return i.List[in].TestCount
		},
		"Iterators": func() string { return i.getTestIterators(in) },
	}).Parse(testAll3)
	if err != nil {
		panic(err)
	}
	err = t.Execute(buf, testAll3)
	if err != nil {
		panic(err)
	}
	return buf.String()
}

func (i IteratorGenerationInstructions) getFunctions() string {
	var str string
	for j := range i.List {
		str += i.getFunction(j)
	}
	return str
}

func (i IteratorGenerationInstructions) getTestFunctions() string {
	var str string
	for j := range i.List {
		str += i.getTestFunction(j)
	}
	return str
}

func main() {
	var o string
	var i string
	var p string
	flag.StringVar(&o, "o", "", "")
	flag.StringVar(&i, "i", "", "")
	flag.StringVar(&p, "p", "", "")
	flag.Parse()

	var f *os.File
	var err error
	fInput, err := os.Open(i)
	if err != nil {
		panic(err)
	}
	inputByte, err := ioutil.ReadAll(fInput)
	if err != nil {
		panic(err)
	}
	var instructions IteratorGenerationInstructions
	if err = yaml.UnmarshalStrict(inputByte, &instructions); err != nil {
		panic(err)
	}
	if o == "" {
		f = os.Stdout
	} else {
		if f, err = os.Create(o); err != nil {
			panic(err)
		}
	}

	if _, err = fmt.Fprintf(f, header+iteratorHeaderImport, strings.Join(os.Args, " "), p); err != nil {
		panic(err)
	}
	if _, err = fmt.Fprintf(f, "%s", instructions.getFunctions()); err != nil {
		panic(err)
	}

	if o == "" {
		return
	} else {
		if f, err = os.Create(strings.TrimRight(o, ".go") + "_test.go"); err != nil {
			panic(err)
		}
	}

	if _, err = fmt.Fprintf(f, header+testHeaderImport, strings.Join(os.Args, " "), p); err != nil {
		panic(err)
	}
	if _, err = fmt.Fprintf(f, "%s", instructions.getTestFunctions()); err != nil {
		panic(err)
	}
}
