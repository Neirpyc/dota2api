// Code generated by ./genIterators -p dota2api -i genIterators.yaml -o iterators.go; DO NOT EDIT.

package dota2api

import (
	. "github.com/franela/goblin"
	"testing"
)

func TestHeroes_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestHeroes_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			h := Heroes{}
			h.heroes = make([]Hero, 100000)

			h.ForEach(func(hero Hero) {
				c++
			})
			g.Assert(c).Equal(100000 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			h := Heroes{}
			h.heroes = make([]Hero, 100000)

			c := make(chan bool, 100000*1)
			h.ForEachAsync(func(hero Hero) {
				c <- true
			})
			for i := 0; i < 100000*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			h := Heroes{}
			h.heroes = make([]Hero, 100000)

			c := make(chan bool, 100000*1)
			h.GoForEach(func(hero Hero) {
				c <- true
			})()
			for i := 0; i < 100000*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working ForEach methodI", func() {
			c := 0
			h := Heroes{}
			h.heroes = make([]Hero, 100000)

			h.ForEachI(func(hero Hero, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(100000 * 1)
		})
		g.It("Have a working ForEachAsyncI method", func() {
			h := Heroes{}
			h.heroes = make([]Hero, 100000)

			c := make(chan int, 100000*1)
			h.ForEachAsyncI(func(hero Hero, index int) {
				c <- index
			})
			sum := 0
			for i := 0; i < 100000*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*1*(100000*1+1)/2 - 100000*1)
		})
		g.It("Have a working GoForEachI method", func() {
			h := Heroes{}
			h.heroes = make([]Hero, 100000)

			c := make(chan int, 100000*1)
			h.GoForEachI(func(hero Hero, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 100000*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*1*(100000*1+1)/2 - 100000*1)
		})
	})
}

func BenchmarkHeroes_ForEach(b *testing.B) {
	h := Heroes{}
	h.heroes = make([]Hero, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	h.ForEach(func(hero Hero) {

	})
}

func BenchmarkHeroes_ForEachAsync(b *testing.B) {
	h := Heroes{}
	h.heroes = make([]Hero, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	h.ForEachAsync(func(hero Hero) {

	})
}

func BenchmarkHeroes_GoForEach(b *testing.B) {
	h := Heroes{}
	h.heroes = make([]Hero, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	h.GoForEach(func(hero Hero) {

	})()
}

func TestItems_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestItems_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			i := Items{}
			i.items = make([]Item, 100000)

			i.ForEach(func(item Item) {
				c++
			})
			g.Assert(c).Equal(100000 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			i := Items{}
			i.items = make([]Item, 100000)

			c := make(chan bool, 100000*1)
			i.ForEachAsync(func(item Item) {
				c <- true
			})
			for i := 0; i < 100000*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			i := Items{}
			i.items = make([]Item, 100000)

			c := make(chan bool, 100000*1)
			i.GoForEach(func(item Item) {
				c <- true
			})()
			for i := 0; i < 100000*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working ForEach methodI", func() {
			c := 0
			i := Items{}
			i.items = make([]Item, 100000)

			i.ForEachI(func(item Item, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(100000 * 1)
		})
		g.It("Have a working ForEachAsyncI method", func() {
			i := Items{}
			i.items = make([]Item, 100000)

			c := make(chan int, 100000*1)
			i.ForEachAsyncI(func(item Item, index int) {
				c <- index
			})
			sum := 0
			for i := 0; i < 100000*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*1*(100000*1+1)/2 - 100000*1)
		})
		g.It("Have a working GoForEachI method", func() {
			i := Items{}
			i.items = make([]Item, 100000)

			c := make(chan int, 100000*1)
			i.GoForEachI(func(item Item, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 100000*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*1*(100000*1+1)/2 - 100000*1)
		})
	})
}

func BenchmarkItems_ForEach(b *testing.B) {
	i := Items{}
	i.items = make([]Item, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	i.ForEach(func(item Item) {

	})
}

func BenchmarkItems_ForEachAsync(b *testing.B) {
	i := Items{}
	i.items = make([]Item, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	i.ForEachAsync(func(item Item) {

	})
}

func BenchmarkItems_GoForEach(b *testing.B) {
	i := Items{}
	i.items = make([]Item, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	i.GoForEach(func(item Item) {

	})()
}

func TestMatchDetailsPlayer_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestMatchDetails_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			m := MatchDetails{}
			m.Radiant = make([]PlayerDetails, 100000)
			m.Dire = make([]PlayerDetails, 100000)

			m.ForEachPlayer(func(player PlayerDetails) {
				c++
			})
			g.Assert(c).Equal(100000 * 2)
		})
		g.It("Have a working ForEachAsync method", func() {
			m := MatchDetails{}
			m.Radiant = make([]PlayerDetails, 100000)
			m.Dire = make([]PlayerDetails, 100000)

			c := make(chan bool, 100000*2)
			m.ForEachPlayerAsync(func(player PlayerDetails) {
				c <- true
			})
			for i := 0; i < 100000*2; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			m := MatchDetails{}
			m.Radiant = make([]PlayerDetails, 100000)
			m.Dire = make([]PlayerDetails, 100000)

			c := make(chan bool, 100000*2)
			m.GoForEachPlayer(func(player PlayerDetails) {
				c <- true
			})()
			for i := 0; i < 100000*2; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working ForEach methodI", func() {
			c := 0
			m := MatchDetails{}
			m.Radiant = make([]PlayerDetails, 100000)
			m.Dire = make([]PlayerDetails, 100000)

			m.ForEachPlayerI(func(player PlayerDetails, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(100000 * 2)
		})
		g.It("Have a working ForEachAsyncI method", func() {
			m := MatchDetails{}
			m.Radiant = make([]PlayerDetails, 100000)
			m.Dire = make([]PlayerDetails, 100000)

			c := make(chan int, 100000*2)
			m.ForEachPlayerAsyncI(func(player PlayerDetails, index int) {
				c <- index
			})
			sum := 0
			for i := 0; i < 100000*2; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*2*(100000*2+1)/2 - 100000*2)
		})
		g.It("Have a working GoForEachI method", func() {
			m := MatchDetails{}
			m.Radiant = make([]PlayerDetails, 100000)
			m.Dire = make([]PlayerDetails, 100000)

			c := make(chan int, 100000*2)
			m.GoForEachPlayerI(func(player PlayerDetails, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 100000*2; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*2*(100000*2+1)/2 - 100000*2)
		})
	})
}

func BenchmarkMatchDetails_ForEachPlayer(b *testing.B) {
	m := MatchDetails{}
	m.Radiant = make([]PlayerDetails, b.N)
	m.Dire = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	m.ForEachPlayer(func(player PlayerDetails) {

	})
}

func BenchmarkMatchDetails_ForEachPlayerAsync(b *testing.B) {
	m := MatchDetails{}
	m.Radiant = make([]PlayerDetails, b.N)
	m.Dire = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	m.ForEachPlayerAsync(func(player PlayerDetails) {

	})
}

func BenchmarkMatchDetails_GoForEachPlayer(b *testing.B) {
	m := MatchDetails{}
	m.Radiant = make([]PlayerDetails, b.N)
	m.Dire = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	m.GoForEachPlayer(func(player PlayerDetails) {

	})()
}

func TestTeam_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestTeam_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			t := Team{}
			t.players = make([]Player, 100000)

			t.ForEach(func(player Player) {
				c++
			})
			g.Assert(c).Equal(100000 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			t := Team{}
			t.players = make([]Player, 100000)

			c := make(chan bool, 100000*1)
			t.ForEachAsync(func(player Player) {
				c <- true
			})
			for i := 0; i < 100000*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			t := Team{}
			t.players = make([]Player, 100000)

			c := make(chan bool, 100000*1)
			t.GoForEach(func(player Player) {
				c <- true
			})()
			for i := 0; i < 100000*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working ForEach methodI", func() {
			c := 0
			t := Team{}
			t.players = make([]Player, 100000)

			t.ForEachI(func(player Player, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(100000 * 1)
		})
		g.It("Have a working ForEachAsyncI method", func() {
			t := Team{}
			t.players = make([]Player, 100000)

			c := make(chan int, 100000*1)
			t.ForEachAsyncI(func(player Player, index int) {
				c <- index
			})
			sum := 0
			for i := 0; i < 100000*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*1*(100000*1+1)/2 - 100000*1)
		})
		g.It("Have a working GoForEachI method", func() {
			t := Team{}
			t.players = make([]Player, 100000)

			c := make(chan int, 100000*1)
			t.GoForEachI(func(player Player, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 100000*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*1*(100000*1+1)/2 - 100000*1)
		})
	})
}

func BenchmarkTeam_ForEach(b *testing.B) {
	t := Team{}
	t.players = make([]Player, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	t.ForEach(func(player Player) {

	})
}

func BenchmarkTeam_ForEachAsync(b *testing.B) {
	t := Team{}
	t.players = make([]Player, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	t.ForEachAsync(func(player Player) {

	})
}

func BenchmarkTeam_GoForEach(b *testing.B) {
	t := Team{}
	t.players = make([]Player, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	t.GoForEach(func(player Player) {

	})()
}

func TestTeamDetails_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestTeamDetails_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			t := TeamDetails{}
			t = make([]PlayerDetails, 100000)

			t.ForEach(func(player PlayerDetails) {
				c++
			})
			g.Assert(c).Equal(100000 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			t := TeamDetails{}
			t = make([]PlayerDetails, 100000)

			c := make(chan bool, 100000*1)
			t.ForEachAsync(func(player PlayerDetails) {
				c <- true
			})
			for i := 0; i < 100000*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			t := TeamDetails{}
			t = make([]PlayerDetails, 100000)

			c := make(chan bool, 100000*1)
			t.GoForEach(func(player PlayerDetails) {
				c <- true
			})()
			for i := 0; i < 100000*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working ForEach methodI", func() {
			c := 0
			t := TeamDetails{}
			t = make([]PlayerDetails, 100000)

			t.ForEachI(func(player PlayerDetails, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(100000 * 1)
		})
		g.It("Have a working ForEachAsyncI method", func() {
			t := TeamDetails{}
			t = make([]PlayerDetails, 100000)

			c := make(chan int, 100000*1)
			t.ForEachAsyncI(func(player PlayerDetails, index int) {
				c <- index
			})
			sum := 0
			for i := 0; i < 100000*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*1*(100000*1+1)/2 - 100000*1)
		})
		g.It("Have a working GoForEachI method", func() {
			t := TeamDetails{}
			t = make([]PlayerDetails, 100000)

			c := make(chan int, 100000*1)
			t.GoForEachI(func(player PlayerDetails, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 100000*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*1*(100000*1+1)/2 - 100000*1)
		})
	})
}

func BenchmarkTeamDetails_ForEach(b *testing.B) {
	t := TeamDetails{}
	t = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	t.ForEach(func(player PlayerDetails) {

	})
}

func BenchmarkTeamDetails_ForEachAsync(b *testing.B) {
	t := TeamDetails{}
	t = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	t.ForEachAsync(func(player PlayerDetails) {

	})
}

func BenchmarkTeamDetails_GoForEach(b *testing.B) {
	t := TeamDetails{}
	t = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	t.GoForEach(func(player PlayerDetails) {

	})()
}

func TestPicksBansPicksBans_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestPicksBans_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			p := PicksBans{}
			p = make([]PickBan, 100000)

			p.ForEachPicksBans(func(pickBan PickBan) {
				c++
			})
			g.Assert(c).Equal(100000 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			p := PicksBans{}
			p = make([]PickBan, 100000)

			c := make(chan bool, 100000*1)
			p.ForEachPicksBansAsync(func(pickBan PickBan) {
				c <- true
			})
			for i := 0; i < 100000*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			p := PicksBans{}
			p = make([]PickBan, 100000)

			c := make(chan bool, 100000*1)
			p.GoForEachPicksBans(func(pickBan PickBan) {
				c <- true
			})()
			for i := 0; i < 100000*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working ForEach methodI", func() {
			c := 0
			p := PicksBans{}
			p = make([]PickBan, 100000)

			p.ForEachPicksBansI(func(pickBan PickBan, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(100000 * 1)
		})
		g.It("Have a working ForEachAsyncI method", func() {
			p := PicksBans{}
			p = make([]PickBan, 100000)

			c := make(chan int, 100000*1)
			p.ForEachPicksBansAsyncI(func(pickBan PickBan, index int) {
				c <- index
			})
			sum := 0
			for i := 0; i < 100000*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*1*(100000*1+1)/2 - 100000*1)
		})
		g.It("Have a working GoForEachI method", func() {
			p := PicksBans{}
			p = make([]PickBan, 100000)

			c := make(chan int, 100000*1)
			p.GoForEachPicksBansI(func(pickBan PickBan, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 100000*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*1*(100000*1+1)/2 - 100000*1)
		})
	})
}

func BenchmarkPicksBans_ForEachPicksBans(b *testing.B) {
	p := PicksBans{}
	p = make([]PickBan, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	p.ForEachPicksBans(func(pickBan PickBan) {

	})
}

func BenchmarkPicksBans_ForEachPicksBansAsync(b *testing.B) {
	p := PicksBans{}
	p = make([]PickBan, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	p.ForEachPicksBansAsync(func(pickBan PickBan) {

	})
}

func BenchmarkPicksBans_GoForEachPicksBans(b *testing.B) {
	p := PicksBans{}
	p = make([]PickBan, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	p.GoForEachPicksBans(func(pickBan PickBan) {

	})()
}

func TestAbilityUpgradesAbilityUpgrades_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestAbilityUpgrades_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			a := AbilityUpgrades{}
			a = make([]AbilityUpgrade, 100000)

			a.ForEachAbilityUpgrades(func(abilityUpgrade AbilityUpgrade) {
				c++
			})
			g.Assert(c).Equal(100000 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			a := AbilityUpgrades{}
			a = make([]AbilityUpgrade, 100000)

			c := make(chan bool, 100000*1)
			a.ForEachAbilityUpgradesAsync(func(abilityUpgrade AbilityUpgrade) {
				c <- true
			})
			for i := 0; i < 100000*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			a := AbilityUpgrades{}
			a = make([]AbilityUpgrade, 100000)

			c := make(chan bool, 100000*1)
			a.GoForEachAbilityUpgrades(func(abilityUpgrade AbilityUpgrade) {
				c <- true
			})()
			for i := 0; i < 100000*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working ForEach methodI", func() {
			c := 0
			a := AbilityUpgrades{}
			a = make([]AbilityUpgrade, 100000)

			a.ForEachAbilityUpgradesI(func(abilityUpgrade AbilityUpgrade, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(100000 * 1)
		})
		g.It("Have a working ForEachAsyncI method", func() {
			a := AbilityUpgrades{}
			a = make([]AbilityUpgrade, 100000)

			c := make(chan int, 100000*1)
			a.ForEachAbilityUpgradesAsyncI(func(abilityUpgrade AbilityUpgrade, index int) {
				c <- index
			})
			sum := 0
			for i := 0; i < 100000*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*1*(100000*1+1)/2 - 100000*1)
		})
		g.It("Have a working GoForEachI method", func() {
			a := AbilityUpgrades{}
			a = make([]AbilityUpgrade, 100000)

			c := make(chan int, 100000*1)
			a.GoForEachAbilityUpgradesI(func(abilityUpgrade AbilityUpgrade, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 100000*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(100000*1*(100000*1+1)/2 - 100000*1)
		})
	})
}

func BenchmarkAbilityUpgrades_ForEachAbilityUpgrades(b *testing.B) {
	a := AbilityUpgrades{}
	a = make([]AbilityUpgrade, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	a.ForEachAbilityUpgrades(func(abilityUpgrade AbilityUpgrade) {

	})
}

func BenchmarkAbilityUpgrades_ForEachAbilityUpgradesAsync(b *testing.B) {
	a := AbilityUpgrades{}
	a = make([]AbilityUpgrade, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	a.ForEachAbilityUpgradesAsync(func(abilityUpgrade AbilityUpgrade) {

	})
}

func BenchmarkAbilityUpgrades_GoForEachAbilityUpgrades(b *testing.B) {
	a := AbilityUpgrades{}
	a = make([]AbilityUpgrade, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	a.GoForEachAbilityUpgrades(func(abilityUpgrade AbilityUpgrade) {

	})()
}
