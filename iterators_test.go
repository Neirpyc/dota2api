// Code generated by ./genIterators -p dota2api -i genIterators.yaml -o iterators.go; DO NOT EDIT.

package dota2api

import (
	. "github.com/franela/goblin"
	"testing"
)

func TestHeroes_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestHeroes_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			h := Heroes{}
			h.heroes = make([]Hero, 10)

			h.ForEach(func(hero Hero) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			h := Heroes{}
			h.heroes = make([]Hero, 10)

			c := make(chan bool, 10*1)
			h.ForEachAsync(func(hero Hero) {
				c <- true
			})
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			h := Heroes{}
			h.heroes = make([]Hero, 10)

			c := make(chan bool, 10*1)
			h.GoForEach(func(hero Hero) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
	})
}
func TestItems_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestItems_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			i := Items{}
			i.items = make([]Item, 10)

			i.ForEach(func(item Item) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			i := Items{}
			i.items = make([]Item, 10)

			c := make(chan bool, 10*1)
			i.ForEachAsync(func(item Item) {
				c <- true
			})
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			i := Items{}
			i.items = make([]Item, 10)

			c := make(chan bool, 10*1)
			i.GoForEach(func(item Item) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
	})
}
func TestMatchPlayer_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestMatch_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			m := Match{}
			m.Radiant = make([]PlayerDetails, 10)
			m.Dire = make([]PlayerDetails, 10)

			m.ForEachPlayer(func(player PlayerDetails) {
				c++
			})
			g.Assert(c).Equal(10 * 2)
		})
		g.It("Have a working ForEachAsync method", func() {
			m := Match{}
			m.Radiant = make([]PlayerDetails, 10)
			m.Dire = make([]PlayerDetails, 10)

			c := make(chan bool, 10*2)
			m.ForEachPlayerAsync(func(player PlayerDetails) {
				c <- true
			})
			for i := 0; i < 10*2; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			m := Match{}
			m.Radiant = make([]PlayerDetails, 10)
			m.Dire = make([]PlayerDetails, 10)

			c := make(chan bool, 10*2)
			m.GoForEachPlayer(func(player PlayerDetails) {
				c <- true
			})()
			for i := 0; i < 10*2; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
	})
}
func TestTeam_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestTeam_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			t := Team{}
			t.players = make([]Player, 10)

			t.ForEach(func(player Player) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			t := Team{}
			t.players = make([]Player, 10)

			c := make(chan bool, 10*1)
			t.ForEachAsync(func(player Player) {
				c <- true
			})
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			t := Team{}
			t.players = make([]Player, 10)

			c := make(chan bool, 10*1)
			t.GoForEach(func(player Player) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
	})
}
func TestTeamDetails_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestTeamDetails_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			t := TeamDetails{}
			t = make([]PlayerDetails, 10)

			t.ForEach(func(player PlayerDetails) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			t := TeamDetails{}
			t = make([]PlayerDetails, 10)

			c := make(chan bool, 10*1)
			t.ForEachAsync(func(player PlayerDetails) {
				c <- true
			})
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			t := TeamDetails{}
			t = make([]PlayerDetails, 10)

			c := make(chan bool, 10*1)
			t.GoForEach(func(player PlayerDetails) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
	})
}
