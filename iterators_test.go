// Code generated by ./genIterators -p dota2api -i genIterators.yaml -o iterators.go; DO NOT EDIT.

package dota2api

import (
	. "github.com/franela/goblin"
	"testing"
)

func TestHeroes_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestHeroes_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			h := Heroes{}
			h.heroes = make([]Hero, 10)

			h.ForEach(func(hero Hero) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			h := Heroes{}
			h.heroes = make([]Hero, 10)

			c := make(chan bool, 10*1)
			h.ForEachAsync(func(hero Hero) {
				c <- true
			})
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			h := Heroes{}
			h.heroes = make([]Hero, 10)

			c := make(chan bool, 10*1)
			h.GoForEach(func(hero Hero) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
	})
}

func BenchmarkHeroes_ForEach(b *testing.B) {
	h := Heroes{}
	h.heroes = make([]Hero, b.N)

	b.ReportAllocs()
	b.StartTimer()
	h.ForEach(func(hero Hero) {

	})
}

func BenchmarkHeroes_ForEachAsync(b *testing.B) {
	h := Heroes{}
	h.heroes = make([]Hero, b.N)

	b.ReportAllocs()
	b.StartTimer()
	h.ForEachAsync(func(hero Hero) {

	})
}

func BenchmarkHeroes_GoForEach(b *testing.B) {
	h := Heroes{}
	h.heroes = make([]Hero, b.N)

	b.ReportAllocs()
	b.StartTimer()
	h.GoForEach(func(hero Hero) {

	})()
}
func TestItems_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestItems_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			i := Items{}
			i.items = make([]Item, 10)

			i.ForEach(func(item Item) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			i := Items{}
			i.items = make([]Item, 10)

			c := make(chan bool, 10*1)
			i.ForEachAsync(func(item Item) {
				c <- true
			})
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			i := Items{}
			i.items = make([]Item, 10)

			c := make(chan bool, 10*1)
			i.GoForEach(func(item Item) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
	})
}

func BenchmarkItems_ForEach(b *testing.B) {
	i := Items{}
	i.items = make([]Item, b.N)

	b.ReportAllocs()
	b.StartTimer()
	i.ForEach(func(item Item) {

	})
}

func BenchmarkItems_ForEachAsync(b *testing.B) {
	i := Items{}
	i.items = make([]Item, b.N)

	b.ReportAllocs()
	b.StartTimer()
	i.ForEachAsync(func(item Item) {

	})
}

func BenchmarkItems_GoForEach(b *testing.B) {
	i := Items{}
	i.items = make([]Item, b.N)

	b.ReportAllocs()
	b.StartTimer()
	i.GoForEach(func(item Item) {

	})()
}
func TestMatchDetailsPlayer_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestMatchDetails_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			m := MatchDetails{}
			m.Radiant = make([]PlayerDetails, 10)
			m.Dire = make([]PlayerDetails, 10)

			m.ForEachPlayer(func(player PlayerDetails) {
				c++
			})
			g.Assert(c).Equal(10 * 2)
		})
		g.It("Have a working ForEachAsync method", func() {
			m := MatchDetails{}
			m.Radiant = make([]PlayerDetails, 10)
			m.Dire = make([]PlayerDetails, 10)

			c := make(chan bool, 10*2)
			m.ForEachPlayerAsync(func(player PlayerDetails) {
				c <- true
			})
			for i := 0; i < 10*2; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			m := MatchDetails{}
			m.Radiant = make([]PlayerDetails, 10)
			m.Dire = make([]PlayerDetails, 10)

			c := make(chan bool, 10*2)
			m.GoForEachPlayer(func(player PlayerDetails) {
				c <- true
			})()
			for i := 0; i < 10*2; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
	})
}

func BenchmarkMatchDetails_ForEachPlayer(b *testing.B) {
	m := MatchDetails{}
	m.Radiant = make([]PlayerDetails, b.N)
	m.Dire = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.StartTimer()
	m.ForEachPlayer(func(player PlayerDetails) {

	})
}

func BenchmarkMatchDetails_ForEachPlayerAsync(b *testing.B) {
	m := MatchDetails{}
	m.Radiant = make([]PlayerDetails, b.N)
	m.Dire = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.StartTimer()
	m.ForEachPlayerAsync(func(player PlayerDetails) {

	})
}

func BenchmarkMatchDetails_GoForEachPlayer(b *testing.B) {
	m := MatchDetails{}
	m.Radiant = make([]PlayerDetails, b.N)
	m.Dire = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.StartTimer()
	m.GoForEachPlayer(func(player PlayerDetails) {

	})()
}
func TestTeam_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestTeam_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			t := Team{}
			t.players = make([]Player, 10)

			t.ForEach(func(player Player) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			t := Team{}
			t.players = make([]Player, 10)

			c := make(chan bool, 10*1)
			t.ForEachAsync(func(player Player) {
				c <- true
			})
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			t := Team{}
			t.players = make([]Player, 10)

			c := make(chan bool, 10*1)
			t.GoForEach(func(player Player) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
	})
}

func BenchmarkTeam_ForEach(b *testing.B) {
	t := Team{}
	t.players = make([]Player, b.N)

	b.ReportAllocs()
	b.StartTimer()
	t.ForEach(func(player Player) {

	})
}

func BenchmarkTeam_ForEachAsync(b *testing.B) {
	t := Team{}
	t.players = make([]Player, b.N)

	b.ReportAllocs()
	b.StartTimer()
	t.ForEachAsync(func(player Player) {

	})
}

func BenchmarkTeam_GoForEach(b *testing.B) {
	t := Team{}
	t.players = make([]Player, b.N)

	b.ReportAllocs()
	b.StartTimer()
	t.GoForEach(func(player Player) {

	})()
}
func TestTeamDetails_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestTeamDetails_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			t := TeamDetails{}
			t = make([]PlayerDetails, 10)

			t.ForEach(func(player PlayerDetails) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			t := TeamDetails{}
			t = make([]PlayerDetails, 10)

			c := make(chan bool, 10*1)
			t.ForEachAsync(func(player PlayerDetails) {
				c <- true
			})
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			t := TeamDetails{}
			t = make([]PlayerDetails, 10)

			c := make(chan bool, 10*1)
			t.GoForEach(func(player PlayerDetails) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
	})
}

func BenchmarkTeamDetails_ForEach(b *testing.B) {
	t := TeamDetails{}
	t = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.StartTimer()
	t.ForEach(func(player PlayerDetails) {

	})
}

func BenchmarkTeamDetails_ForEachAsync(b *testing.B) {
	t := TeamDetails{}
	t = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.StartTimer()
	t.ForEachAsync(func(player PlayerDetails) {

	})
}

func BenchmarkTeamDetails_GoForEach(b *testing.B) {
	t := TeamDetails{}
	t = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.StartTimer()
	t.GoForEach(func(player PlayerDetails) {

	})()
}
func TestPicksBansPicksBans_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestPicksBans_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			p := PicksBans{}
			p = make([]PickBan, 10)

			p.ForEachPicksBans(func(pickBan PickBan) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			p := PicksBans{}
			p = make([]PickBan, 10)

			c := make(chan bool, 10*1)
			p.ForEachPicksBansAsync(func(pickBan PickBan) {
				c <- true
			})
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			p := PicksBans{}
			p = make([]PickBan, 10)

			c := make(chan bool, 10*1)
			p.GoForEachPicksBans(func(pickBan PickBan) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
	})
}

func BenchmarkPicksBans_ForEachPicksBans(b *testing.B) {
	p := PicksBans{}
	p = make([]PickBan, b.N)

	b.ReportAllocs()
	b.StartTimer()
	p.ForEachPicksBans(func(pickBan PickBan) {

	})
}

func BenchmarkPicksBans_ForEachPicksBansAsync(b *testing.B) {
	p := PicksBans{}
	p = make([]PickBan, b.N)

	b.ReportAllocs()
	b.StartTimer()
	p.ForEachPicksBansAsync(func(pickBan PickBan) {

	})
}

func BenchmarkPicksBans_GoForEachPicksBans(b *testing.B) {
	p := PicksBans{}
	p = make([]PickBan, b.N)

	b.ReportAllocs()
	b.StartTimer()
	p.GoForEachPicksBans(func(pickBan PickBan) {

	})()
}
func TestAbilityUpgradesAbilityUpgrades_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestAbilityUpgrades_Iterators", func() {
		g.It("Have a working ForEach method", func() {
			c := 0
			a := AbilityUpgrades{}
			a = make([]AbilityUpgrade, 10)

			a.ForEachAbilityUpgrades(func(abilityUpgrade AbilityUpgrade) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Have a working ForEachAsync method", func() {
			a := AbilityUpgrades{}
			a = make([]AbilityUpgrade, 10)

			c := make(chan bool, 10*1)
			a.ForEachAbilityUpgradesAsync(func(abilityUpgrade AbilityUpgrade) {
				c <- true
			})
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Have a working GoForEach method", func() {
			a := AbilityUpgrades{}
			a = make([]AbilityUpgrade, 10)

			c := make(chan bool, 10*1)
			a.GoForEachAbilityUpgrades(func(abilityUpgrade AbilityUpgrade) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
	})
}

func BenchmarkAbilityUpgrades_ForEachAbilityUpgrades(b *testing.B) {
	a := AbilityUpgrades{}
	a = make([]AbilityUpgrade, b.N)

	b.ReportAllocs()
	b.StartTimer()
	a.ForEachAbilityUpgrades(func(abilityUpgrade AbilityUpgrade) {

	})
}

func BenchmarkAbilityUpgrades_ForEachAbilityUpgradesAsync(b *testing.B) {
	a := AbilityUpgrades{}
	a = make([]AbilityUpgrade, b.N)

	b.ReportAllocs()
	b.StartTimer()
	a.ForEachAbilityUpgradesAsync(func(abilityUpgrade AbilityUpgrade) {

	})
}

func BenchmarkAbilityUpgrades_GoForEachAbilityUpgrades(b *testing.B) {
	a := AbilityUpgrades{}
	a = make([]AbilityUpgrade, b.N)

	b.ReportAllocs()
	b.StartTimer()
	a.GoForEachAbilityUpgrades(func(abilityUpgrade AbilityUpgrade) {

	})()
}
