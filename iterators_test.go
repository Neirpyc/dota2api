// Code generated by ./genIterators -p dota2api -i genIterators.yaml -o iterators.go; DO NOT EDIT.

package dota2api

import (
	. "github.com/franela/goblin"
	"testing"
)

func TestHeroes_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestHeroes_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			h := Heroes{}
			h.heroes = make([]Hero, 10)

			h.ForEach(func(hero Hero) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEach method", func() {
			h := Heroes{}
			h.heroes = make([]Hero, 10)

			c := make(chan bool, 10*1)
			h.GoForEach(func(hero Hero) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			h := Heroes{}
			h.heroes = make([]Hero, 10)

			h.ForEachI(func(hero Hero, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEachI method", func() {
			h := Heroes{}
			h.heroes = make([]Hero, 10)

			c := make(chan int, 10*1)
			h.GoForEachI(func(hero Hero, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 10*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(10*1*(10*1+1)/2 - 10*1)
		})
	})
}

func BenchmarkHeroes_ForEach(b *testing.B) {
	h := Heroes{}
	h.heroes = make([]Hero, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	h.ForEach(func(hero Hero) {

	})
}

func BenchmarkHeroes_GoForEach(b *testing.B) {
	h := Heroes{}
	h.heroes = make([]Hero, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	h.GoForEach(func(hero Hero) {

	})()
}

func TestItems_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestItems_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			i := Items{}
			i.items = make([]Item, 10)

			i.ForEach(func(item Item) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEach method", func() {
			i := Items{}
			i.items = make([]Item, 10)

			c := make(chan bool, 10*1)
			i.GoForEach(func(item Item) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			i := Items{}
			i.items = make([]Item, 10)

			i.ForEachI(func(item Item, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEachI method", func() {
			i := Items{}
			i.items = make([]Item, 10)

			c := make(chan int, 10*1)
			i.GoForEachI(func(item Item, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 10*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(10*1*(10*1+1)/2 - 10*1)
		})
	})
}

func BenchmarkItems_ForEach(b *testing.B) {
	i := Items{}
	i.items = make([]Item, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	i.ForEach(func(item Item) {

	})
}

func BenchmarkItems_GoForEach(b *testing.B) {
	i := Items{}
	i.items = make([]Item, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	i.GoForEach(func(item Item) {

	})()
}

func TestMatchDetailsPlayer_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestMatchDetails_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			m := MatchDetails{}
			m.Radiant = make([]PlayerDetails, 10)
			m.Dire = make([]PlayerDetails, 10)

			m.ForEachPlayer(func(player PlayerDetails) {
				c++
			})
			g.Assert(c).Equal(10 * 2)
		})
		g.It("Has a working GoForEach method", func() {
			m := MatchDetails{}
			m.Radiant = make([]PlayerDetails, 10)
			m.Dire = make([]PlayerDetails, 10)

			c := make(chan bool, 10*2)
			m.GoForEachPlayer(func(player PlayerDetails) {
				c <- true
			})()
			for i := 0; i < 10*2; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			m := MatchDetails{}
			m.Radiant = make([]PlayerDetails, 10)
			m.Dire = make([]PlayerDetails, 10)

			m.ForEachPlayerI(func(player PlayerDetails, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(10 * 2)
		})
		g.It("Has a working GoForEachI method", func() {
			m := MatchDetails{}
			m.Radiant = make([]PlayerDetails, 10)
			m.Dire = make([]PlayerDetails, 10)

			c := make(chan int, 10*2)
			m.GoForEachPlayerI(func(player PlayerDetails, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 10*2; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(10*2*(10*2+1)/2 - 10*2)
		})
	})
}

func BenchmarkMatchDetails_ForEachPlayer(b *testing.B) {
	m := MatchDetails{}
	m.Radiant = make([]PlayerDetails, b.N)
	m.Dire = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	m.ForEachPlayer(func(player PlayerDetails) {

	})
}

func BenchmarkMatchDetails_GoForEachPlayer(b *testing.B) {
	m := MatchDetails{}
	m.Radiant = make([]PlayerDetails, b.N)
	m.Dire = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	m.GoForEachPlayer(func(player PlayerDetails) {

	})()
}

func TestTeam_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestTeam_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			t := Team{}
			t.players = make([]Player, 10)

			t.ForEach(func(player Player) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEach method", func() {
			t := Team{}
			t.players = make([]Player, 10)

			c := make(chan bool, 10*1)
			t.GoForEach(func(player Player) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			t := Team{}
			t.players = make([]Player, 10)

			t.ForEachI(func(player Player, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEachI method", func() {
			t := Team{}
			t.players = make([]Player, 10)

			c := make(chan int, 10*1)
			t.GoForEachI(func(player Player, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 10*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(10*1*(10*1+1)/2 - 10*1)
		})
	})
}

func BenchmarkTeam_ForEach(b *testing.B) {
	t := Team{}
	t.players = make([]Player, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	t.ForEach(func(player Player) {

	})
}

func BenchmarkTeam_GoForEach(b *testing.B) {
	t := Team{}
	t.players = make([]Player, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	t.GoForEach(func(player Player) {

	})()
}

func TestTeamDetails_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestTeamDetails_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			t := TeamDetails{}
			t = make([]PlayerDetails, 10)

			t.ForEach(func(player PlayerDetails) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEach method", func() {
			t := TeamDetails{}
			t = make([]PlayerDetails, 10)

			c := make(chan bool, 10*1)
			t.GoForEach(func(player PlayerDetails) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			t := TeamDetails{}
			t = make([]PlayerDetails, 10)

			t.ForEachI(func(player PlayerDetails, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEachI method", func() {
			t := TeamDetails{}
			t = make([]PlayerDetails, 10)

			c := make(chan int, 10*1)
			t.GoForEachI(func(player PlayerDetails, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 10*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(10*1*(10*1+1)/2 - 10*1)
		})
	})
}

func BenchmarkTeamDetails_ForEach(b *testing.B) {
	t := TeamDetails{}
	t = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	t.ForEach(func(player PlayerDetails) {

	})
}

func BenchmarkTeamDetails_GoForEach(b *testing.B) {
	t := TeamDetails{}
	t = make([]PlayerDetails, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	t.GoForEach(func(player PlayerDetails) {

	})()
}

func TestPicksBansPicksBans_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestPicksBans_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			p := PicksBans{}
			p = make([]PickBan, 10)

			p.ForEachPicksBans(func(pickBan PickBan) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEach method", func() {
			p := PicksBans{}
			p = make([]PickBan, 10)

			c := make(chan bool, 10*1)
			p.GoForEachPicksBans(func(pickBan PickBan) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			p := PicksBans{}
			p = make([]PickBan, 10)

			p.ForEachPicksBansI(func(pickBan PickBan, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEachI method", func() {
			p := PicksBans{}
			p = make([]PickBan, 10)

			c := make(chan int, 10*1)
			p.GoForEachPicksBansI(func(pickBan PickBan, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 10*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(10*1*(10*1+1)/2 - 10*1)
		})
	})
}

func BenchmarkPicksBans_ForEachPicksBans(b *testing.B) {
	p := PicksBans{}
	p = make([]PickBan, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	p.ForEachPicksBans(func(pickBan PickBan) {

	})
}

func BenchmarkPicksBans_GoForEachPicksBans(b *testing.B) {
	p := PicksBans{}
	p = make([]PickBan, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	p.GoForEachPicksBans(func(pickBan PickBan) {

	})()
}

func TestAbilityUpgradesAbilityUpgrades_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestAbilityUpgrades_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			a := AbilityUpgrades{}
			a = make([]AbilityUpgrade, 10)

			a.ForEachAbilityUpgrades(func(abilityUpgrade AbilityUpgrade) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEach method", func() {
			a := AbilityUpgrades{}
			a = make([]AbilityUpgrade, 10)

			c := make(chan bool, 10*1)
			a.GoForEachAbilityUpgrades(func(abilityUpgrade AbilityUpgrade) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			a := AbilityUpgrades{}
			a = make([]AbilityUpgrade, 10)

			a.ForEachAbilityUpgradesI(func(abilityUpgrade AbilityUpgrade, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEachI method", func() {
			a := AbilityUpgrades{}
			a = make([]AbilityUpgrade, 10)

			c := make(chan int, 10*1)
			a.GoForEachAbilityUpgradesI(func(abilityUpgrade AbilityUpgrade, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 10*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(10*1*(10*1+1)/2 - 10*1)
		})
	})
}

func BenchmarkAbilityUpgrades_ForEachAbilityUpgrades(b *testing.B) {
	a := AbilityUpgrades{}
	a = make([]AbilityUpgrade, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	a.ForEachAbilityUpgrades(func(abilityUpgrade AbilityUpgrade) {

	})
}

func BenchmarkAbilityUpgrades_GoForEachAbilityUpgrades(b *testing.B) {
	a := AbilityUpgrades{}
	a = make([]AbilityUpgrade, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	a.GoForEachAbilityUpgrades(func(abilityUpgrade AbilityUpgrade) {

	})()
}

func TestFriends_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestFriends_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			fr := Friends{}
			fr = make([]Friend, 10)

			fr.ForEach(func(friend Friend) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEach method", func() {
			fr := Friends{}
			fr = make([]Friend, 10)

			c := make(chan bool, 10*1)
			fr.GoForEach(func(friend Friend) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			fr := Friends{}
			fr = make([]Friend, 10)

			fr.ForEachI(func(friend Friend, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEachI method", func() {
			fr := Friends{}
			fr = make([]Friend, 10)

			c := make(chan int, 10*1)
			fr.GoForEachI(func(friend Friend, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 10*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(10*1*(10*1+1)/2 - 10*1)
		})
	})
}

func BenchmarkFriends_ForEach(b *testing.B) {
	fr := Friends{}
	fr = make([]Friend, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	fr.ForEach(func(friend Friend) {

	})
}

func BenchmarkFriends_GoForEach(b *testing.B) {
	fr := Friends{}
	fr = make([]Friend, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	fr.GoForEach(func(friend Friend) {

	})()
}

func TestLiveGamePlayers_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestLiveGamePlayers_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			l := LiveGamePlayers{}
			l = make([]LiveGamePlayer, 10)

			l.ForEach(func(lP LiveGamePlayer) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEach method", func() {
			l := LiveGamePlayers{}
			l = make([]LiveGamePlayer, 10)

			c := make(chan bool, 10*1)
			l.GoForEach(func(lP LiveGamePlayer) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			l := LiveGamePlayers{}
			l = make([]LiveGamePlayer, 10)

			l.ForEachI(func(lP LiveGamePlayer, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEachI method", func() {
			l := LiveGamePlayers{}
			l = make([]LiveGamePlayer, 10)

			c := make(chan int, 10*1)
			l.GoForEachI(func(lP LiveGamePlayer, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 10*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(10*1*(10*1+1)/2 - 10*1)
		})
	})
}

func BenchmarkLiveGamePlayers_ForEach(b *testing.B) {
	l := LiveGamePlayers{}
	l = make([]LiveGamePlayer, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	l.ForEach(func(lP LiveGamePlayer) {

	})
}

func BenchmarkLiveGamePlayers_GoForEach(b *testing.B) {
	l := LiveGamePlayers{}
	l = make([]LiveGamePlayer, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	l.GoForEach(func(lP LiveGamePlayer) {

	})()
}

func TestSideLivePick_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestSideLive_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			s := SideLive{}
			s.Picks = make([]Hero, 10)

			s.ForEachPick(func(picks Hero) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEach method", func() {
			s := SideLive{}
			s.Picks = make([]Hero, 10)

			c := make(chan bool, 10*1)
			s.GoForEachPick(func(picks Hero) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			s := SideLive{}
			s.Picks = make([]Hero, 10)

			s.ForEachPickI(func(picks Hero, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEachI method", func() {
			s := SideLive{}
			s.Picks = make([]Hero, 10)

			c := make(chan int, 10*1)
			s.GoForEachPickI(func(picks Hero, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 10*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(10*1*(10*1+1)/2 - 10*1)
		})
	})
}

func BenchmarkSideLive_ForEachPick(b *testing.B) {
	s := SideLive{}
	s.Picks = make([]Hero, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	s.ForEachPick(func(picks Hero) {

	})
}

func BenchmarkSideLive_GoForEachPick(b *testing.B) {
	s := SideLive{}
	s.Picks = make([]Hero, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	s.GoForEachPick(func(picks Hero) {

	})()
}

func TestSideLiveBan_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestSideLive_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			s := SideLive{}
			s.Bans = make([]Hero, 10)

			s.ForEachBan(func(bans Hero) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEach method", func() {
			s := SideLive{}
			s.Bans = make([]Hero, 10)

			c := make(chan bool, 10*1)
			s.GoForEachBan(func(bans Hero) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			s := SideLive{}
			s.Bans = make([]Hero, 10)

			s.ForEachBanI(func(bans Hero, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEachI method", func() {
			s := SideLive{}
			s.Bans = make([]Hero, 10)

			c := make(chan int, 10*1)
			s.GoForEachBanI(func(bans Hero, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 10*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(10*1*(10*1+1)/2 - 10*1)
		})
	})
}

func BenchmarkSideLive_ForEachBan(b *testing.B) {
	s := SideLive{}
	s.Bans = make([]Hero, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	s.ForEachBan(func(bans Hero) {

	})
}

func BenchmarkSideLive_GoForEachBan(b *testing.B) {
	s := SideLive{}
	s.Bans = make([]Hero, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	s.GoForEachBan(func(bans Hero) {

	})()
}

func TestSideLivePlayer_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestSideLive_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			s := SideLive{}
			s.Players = make([]PlayerLive, 10)

			s.ForEachPlayer(func(players PlayerLive) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEach method", func() {
			s := SideLive{}
			s.Players = make([]PlayerLive, 10)

			c := make(chan bool, 10*1)
			s.GoForEachPlayer(func(players PlayerLive) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			s := SideLive{}
			s.Players = make([]PlayerLive, 10)

			s.ForEachPlayerI(func(players PlayerLive, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEachI method", func() {
			s := SideLive{}
			s.Players = make([]PlayerLive, 10)

			c := make(chan int, 10*1)
			s.GoForEachPlayerI(func(players PlayerLive, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 10*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(10*1*(10*1+1)/2 - 10*1)
		})
	})
}

func BenchmarkSideLive_ForEachPlayer(b *testing.B) {
	s := SideLive{}
	s.Players = make([]PlayerLive, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	s.ForEachPlayer(func(players PlayerLive) {

	})
}

func BenchmarkSideLive_GoForEachPlayer(b *testing.B) {
	s := SideLive{}
	s.Players = make([]PlayerLive, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	s.GoForEachPlayer(func(players PlayerLive) {

	})()
}

func TestSideLiveAbility_Iterators(t *testing.T) {
	g := Goblin(t)
	g.Describe("TestSideLive_Iterators", func() {
		g.It("Has a working ForEach method", func() {
			c := 0
			s := SideLive{}
			s.Abilities = make([]LiveAbility, 10)

			s.ForEachAbility(func(abilities LiveAbility) {
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEach method", func() {
			s := SideLive{}
			s.Abilities = make([]LiveAbility, 10)

			c := make(chan bool, 10*1)
			s.GoForEachAbility(func(abilities LiveAbility) {
				c <- true
			})()
			for i := 0; i < 10*1; i++ {
				select {
				case <-c:
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
		})
		g.It("Has a working ForEach methodI", func() {
			c := 0
			s := SideLive{}
			s.Abilities = make([]LiveAbility, 10)

			s.ForEachAbilityI(func(abilities LiveAbility, index int) {
				g.Assert(index).Equal(c)
				c++
			})
			g.Assert(c).Equal(10 * 1)
		})
		g.It("Has a working GoForEachI method", func() {
			s := SideLive{}
			s.Abilities = make([]LiveAbility, 10)

			c := make(chan int, 10*1)
			s.GoForEachAbilityI(func(abilities LiveAbility, index int) {
				c <- index
			})()
			sum := 0
			for i := 0; i < 10*1; i++ {
				select {
				case read := <-c:
					sum += read
					continue
				default:
					g.Fail("Skipped element in for each")
				}
			}
			g.Assert(sum).Equal(10*1*(10*1+1)/2 - 10*1)
		})
	})
}

func BenchmarkSideLive_ForEachAbility(b *testing.B) {
	s := SideLive{}
	s.Abilities = make([]LiveAbility, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	s.ForEachAbility(func(abilities LiveAbility) {

	})
}

func BenchmarkSideLive_GoForEachAbility(b *testing.B) {
	s := SideLive{}
	s.Abilities = make([]LiveAbility, b.N)

	b.ReportAllocs()
	b.ResetTimer()
	s.GoForEachAbility(func(abilities LiveAbility) {

	})()
}
