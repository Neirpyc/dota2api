// Code generated by ./genIterators -p dota2api -i genIterators.yaml -o iterators.go; DO NOT EDIT.

package dota2api

import "sync"

func (h Heroes) ForEachI(f func(hero Hero, index int)) {
	index := 0
	iter := func(heroes []Hero) {
		for _, hero := range heroes {
			f(hero, index)
			index++
		}
	}
	iter(h.heroes)

}

func (h Heroes) GoForEachI(f func(hero Hero, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(heroes []Hero) {
		wg.Add(len(heroes))
		for _, hero := range heroes {
			index++
			index := index
			hero := hero
			go func() {
				f(hero, index)
				wg.Done()
			}()
		}
	}
	iter(h.heroes)

	return wg.Wait
}

func (h Heroes) ForEach(f func(hero Hero)) {
	h.ForEachI(func(hero Hero, index int) {
		f(hero)
	})
}

func (h Heroes) GoForEach(f func(hero Hero)) func() {
	return h.GoForEachI(func(hero Hero, index int) {
		f(hero)
	})
}

func (i Items) ForEachI(f func(item Item, index int)) {
	index := 0
	iter := func(items []Item) {
		for _, item := range items {
			f(item, index)
			index++
		}
	}
	iter(i.items)

}

func (i Items) GoForEachI(f func(item Item, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(items []Item) {
		wg.Add(len(items))
		for _, item := range items {
			index++
			index := index
			item := item
			go func() {
				f(item, index)
				wg.Done()
			}()
		}
	}
	iter(i.items)

	return wg.Wait
}

func (i Items) ForEach(f func(item Item)) {
	i.ForEachI(func(item Item, index int) {
		f(item)
	})
}

func (i Items) GoForEach(f func(item Item)) func() {
	return i.GoForEachI(func(item Item, index int) {
		f(item)
	})
}

func (m MatchDetails) ForEachPlayerI(f func(player PlayerDetails, index int)) {
	index := 0
	iter := func(team []PlayerDetails) {
		for _, p := range team {
			f(p, index)
			index++
		}
	}
	iter(m.Radiant)
	iter(m.Dire)

}

func (m MatchDetails) GoForEachPlayerI(f func(player PlayerDetails, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(team []PlayerDetails) {
		wg.Add(len(team))
		for _, p := range team {
			index++
			index := index
			p := p
			go func() {
				f(p, index)
				wg.Done()
			}()
		}
	}
	iter(m.Radiant)
	iter(m.Dire)

	return wg.Wait
}

func (m MatchDetails) ForEachPlayer(f func(player PlayerDetails)) {
	m.ForEachPlayerI(func(player PlayerDetails, index int) {
		f(player)
	})
}

func (m MatchDetails) GoForEachPlayer(f func(player PlayerDetails)) func() {
	return m.GoForEachPlayerI(func(player PlayerDetails, index int) {
		f(player)
	})
}

func (t Team) ForEachI(f func(player Player, index int)) {
	index := 0
	iter := func(team []Player) {
		for _, p := range team {
			f(p, index)
			index++
		}
	}
	iter(t.players)

}

func (t Team) GoForEachI(f func(player Player, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(team []Player) {
		wg.Add(len(team))
		for _, p := range team {
			index++
			index := index
			p := p
			go func() {
				f(p, index)
				wg.Done()
			}()
		}
	}
	iter(t.players)

	return wg.Wait
}

func (t Team) ForEach(f func(player Player)) {
	t.ForEachI(func(player Player, index int) {
		f(player)
	})
}

func (t Team) GoForEach(f func(player Player)) func() {
	return t.GoForEachI(func(player Player, index int) {
		f(player)
	})
}

func (t TeamDetails) ForEachI(f func(player PlayerDetails, index int)) {
	index := 0
	iter := func(team []PlayerDetails) {
		for _, p := range team {
			f(p, index)
			index++
		}
	}
	iter([]PlayerDetails(t))

}

func (t TeamDetails) GoForEachI(f func(player PlayerDetails, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(team []PlayerDetails) {
		wg.Add(len(team))
		for _, p := range team {
			index++
			index := index
			p := p
			go func() {
				f(p, index)
				wg.Done()
			}()
		}
	}
	iter([]PlayerDetails(t))

	return wg.Wait
}

func (t TeamDetails) ForEach(f func(player PlayerDetails)) {
	t.ForEachI(func(player PlayerDetails, index int) {
		f(player)
	})
}

func (t TeamDetails) GoForEach(f func(player PlayerDetails)) func() {
	return t.GoForEachI(func(player PlayerDetails, index int) {
		f(player)
	})
}

func (p PicksBans) ForEachPicksBansI(f func(pickBan PickBan, index int)) {
	index := 0
	iter := func(pickBan []PickBan) {
		for _, pB := range pickBan {
			f(pB, index)
			index++
		}
	}
	iter([]PickBan(p))

}

func (p PicksBans) GoForEachPicksBansI(f func(pickBan PickBan, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(pickBan []PickBan) {
		wg.Add(len(pickBan))
		for _, pB := range pickBan {
			index++
			index := index
			pB := pB
			go func() {
				f(pB, index)
				wg.Done()
			}()
		}
	}
	iter([]PickBan(p))

	return wg.Wait
}

func (p PicksBans) ForEachPicksBans(f func(pickBan PickBan)) {
	p.ForEachPicksBansI(func(pickBan PickBan, index int) {
		f(pickBan)
	})
}

func (p PicksBans) GoForEachPicksBans(f func(pickBan PickBan)) func() {
	return p.GoForEachPicksBansI(func(pickBan PickBan, index int) {
		f(pickBan)
	})
}

func (a AbilityUpgrades) ForEachAbilityUpgradesI(f func(abilityUpgrade AbilityUpgrade, index int)) {
	index := 0
	iter := func(abilityUpgrade []AbilityUpgrade) {
		for _, aU := range abilityUpgrade {
			f(aU, index)
			index++
		}
	}
	iter([]AbilityUpgrade(a))

}

func (a AbilityUpgrades) GoForEachAbilityUpgradesI(f func(abilityUpgrade AbilityUpgrade, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(abilityUpgrade []AbilityUpgrade) {
		wg.Add(len(abilityUpgrade))
		for _, aU := range abilityUpgrade {
			index++
			index := index
			aU := aU
			go func() {
				f(aU, index)
				wg.Done()
			}()
		}
	}
	iter([]AbilityUpgrade(a))

	return wg.Wait
}

func (a AbilityUpgrades) ForEachAbilityUpgrades(f func(abilityUpgrade AbilityUpgrade)) {
	a.ForEachAbilityUpgradesI(func(abilityUpgrade AbilityUpgrade, index int) {
		f(abilityUpgrade)
	})
}

func (a AbilityUpgrades) GoForEachAbilityUpgrades(f func(abilityUpgrade AbilityUpgrade)) func() {
	return a.GoForEachAbilityUpgradesI(func(abilityUpgrade AbilityUpgrade, index int) {
		f(abilityUpgrade)
	})
}

func (fr Friends) ForEachI(f func(friend Friend, index int)) {
	index := 0
	iter := func(friend []Friend) {
		for _, fr := range friend {
			f(fr, index)
			index++
		}
	}
	iter([]Friend(fr))

}

func (fr Friends) GoForEachI(f func(friend Friend, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(friend []Friend) {
		wg.Add(len(friend))
		for _, fr := range friend {
			index++
			index := index
			fr := fr
			go func() {
				f(fr, index)
				wg.Done()
			}()
		}
	}
	iter([]Friend(fr))

	return wg.Wait
}

func (fr Friends) ForEach(f func(friend Friend)) {
	fr.ForEachI(func(friend Friend, index int) {
		f(friend)
	})
}

func (fr Friends) GoForEach(f func(friend Friend)) func() {
	return fr.GoForEachI(func(friend Friend, index int) {
		f(friend)
	})
}

func (l LiveGamePlayers) ForEachI(f func(lP LiveGamePlayer, index int)) {
	index := 0
	iter := func(lP []LiveGamePlayer) {
		for _, lP := range lP {
			f(lP, index)
			index++
		}
	}
	iter([]LiveGamePlayer(l))

}

func (l LiveGamePlayers) GoForEachI(f func(lP LiveGamePlayer, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(lP []LiveGamePlayer) {
		wg.Add(len(lP))
		for _, lP := range lP {
			index++
			index := index
			lP := lP
			go func() {
				f(lP, index)
				wg.Done()
			}()
		}
	}
	iter([]LiveGamePlayer(l))

	return wg.Wait
}

func (l LiveGamePlayers) ForEach(f func(lP LiveGamePlayer)) {
	l.ForEachI(func(lP LiveGamePlayer, index int) {
		f(lP)
	})
}

func (l LiveGamePlayers) GoForEach(f func(lP LiveGamePlayer)) func() {
	return l.GoForEachI(func(lP LiveGamePlayer, index int) {
		f(lP)
	})
}

func (s SideLive) ForEachPickI(f func(picks Hero, index int)) {
	index := 0
	iter := func(picks []Hero) {
		for _, pick := range picks {
			f(pick, index)
			index++
		}
	}
	iter(s.Picks)

}

func (s SideLive) GoForEachPickI(f func(picks Hero, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(picks []Hero) {
		wg.Add(len(picks))
		for _, pick := range picks {
			index++
			index := index
			pick := pick
			go func() {
				f(pick, index)
				wg.Done()
			}()
		}
	}
	iter(s.Picks)

	return wg.Wait
}

func (s SideLive) ForEachPick(f func(picks Hero)) {
	s.ForEachPickI(func(picks Hero, index int) {
		f(picks)
	})
}

func (s SideLive) GoForEachPick(f func(picks Hero)) func() {
	return s.GoForEachPickI(func(picks Hero, index int) {
		f(picks)
	})
}

func (s SideLive) ForEachBanI(f func(bans Hero, index int)) {
	index := 0
	iter := func(bans []Hero) {
		for _, ban := range bans {
			f(ban, index)
			index++
		}
	}
	iter(s.Bans)

}

func (s SideLive) GoForEachBanI(f func(bans Hero, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(bans []Hero) {
		wg.Add(len(bans))
		for _, ban := range bans {
			index++
			index := index
			ban := ban
			go func() {
				f(ban, index)
				wg.Done()
			}()
		}
	}
	iter(s.Bans)

	return wg.Wait
}

func (s SideLive) ForEachBan(f func(bans Hero)) {
	s.ForEachBanI(func(bans Hero, index int) {
		f(bans)
	})
}

func (s SideLive) GoForEachBan(f func(bans Hero)) func() {
	return s.GoForEachBanI(func(bans Hero, index int) {
		f(bans)
	})
}

func (s SideLive) ForEachPlayerI(f func(players PlayerLive, index int)) {
	index := 0
	iter := func(players []PlayerLive) {
		for _, player := range players {
			f(player, index)
			index++
		}
	}
	iter([]PlayerLive(s.Players))

}

func (s SideLive) GoForEachPlayerI(f func(players PlayerLive, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(players []PlayerLive) {
		wg.Add(len(players))
		for _, player := range players {
			index++
			index := index
			player := player
			go func() {
				f(player, index)
				wg.Done()
			}()
		}
	}
	iter([]PlayerLive(s.Players))

	return wg.Wait
}

func (s SideLive) ForEachPlayer(f func(players PlayerLive)) {
	s.ForEachPlayerI(func(players PlayerLive, index int) {
		f(players)
	})
}

func (s SideLive) GoForEachPlayer(f func(players PlayerLive)) func() {
	return s.GoForEachPlayerI(func(players PlayerLive, index int) {
		f(players)
	})
}

func (s SideLive) ForEachAbilityI(f func(abilities LiveAbility, index int)) {
	index := 0
	iter := func(abilities []LiveAbility) {
		for _, ability := range abilities {
			f(ability, index)
			index++
		}
	}
	iter([]LiveAbility(s.Abilities))

}

func (s SideLive) GoForEachAbilityI(f func(abilities LiveAbility, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(abilities []LiveAbility) {
		wg.Add(len(abilities))
		for _, ability := range abilities {
			index++
			index := index
			ability := ability
			go func() {
				f(ability, index)
				wg.Done()
			}()
		}
	}
	iter([]LiveAbility(s.Abilities))

	return wg.Wait
}

func (s SideLive) ForEachAbility(f func(abilities LiveAbility)) {
	s.ForEachAbilityI(func(abilities LiveAbility, index int) {
		f(abilities)
	})
}

func (s SideLive) GoForEachAbility(f func(abilities LiveAbility)) func() {
	return s.GoForEachAbilityI(func(abilities LiveAbility, index int) {
		f(abilities)
	})
}

func (l LiveGames) ForEachGameI(f func(game LiveGame, index int)) {
	index := 0
	iter := func(games []LiveGame) {
		for _, game := range games {
			f(game, index)
			index++
		}
	}
	iter([]LiveGame(l))

}

func (l LiveGames) GoForEachGameI(f func(game LiveGame, index int)) func() {
	var wg sync.WaitGroup
	index := -1
	iter := func(games []LiveGame) {
		wg.Add(len(games))
		for _, game := range games {
			index++
			index := index
			game := game
			go func() {
				f(game, index)
				wg.Done()
			}()
		}
	}
	iter([]LiveGame(l))

	return wg.Wait
}

func (l LiveGames) ForEachGame(f func(game LiveGame)) {
	l.ForEachGameI(func(game LiveGame, index int) {
		f(game)
	})
}

func (l LiveGames) GoForEachGame(f func(game LiveGame)) func() {
	return l.GoForEachGameI(func(game LiveGame, index int) {
		f(game)
	})
}
